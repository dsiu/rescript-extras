/**
`t<'a>` represents a lazy sequence whose items are only computed upon demand.
*/
type t<'a>

exception ArgumentOfOfRange(string)

/**
`empty` is a sequence with nothing in it; analogous to an empty array.
*/
let empty: t<'a>

/**
`singleton(value)` is a sequence with a single item in it.
*/
let singleton: 'a => t<'a>

/**
`unfold(seed, f)` creates a sequence that contains the elements generated by a
computation. The function `f` is first passed `seed` and then is repeatedly
called to build the sequence. When `f` returns a tuple of `Some(item, seed)`,
`item` is added to the sequence, and `seed` is fed into the next computation.
When `f` returns `None`, the computation is complete.

## Examples

```rescript
Seq.unfold(1, i => i < 100 ? Some(i, i * 2) : None) // [1, 2, 4, 8, 16, 32, 64]
```
*/
let unfold: ('seed, 'seed => option<('a, 'seed)>) => t<'a>

/**
`init(count, f)` initializes a sequence based on a `count` and a function `f`
that is provided index values from 0 up to `count-1`.

## Examples

```rescript
Seq.init(3, inx => inx * 2) // [0, 2, 4]
```
*/
let init: (int, int => 'a) => t<'a>

/**
`repeat(count, item)` is the sequence of `item` repeated exacly `count` times.
*/
let repeat: (int, 'a) => t<'a>

/**
`repeatWith(count, f)` is the sequence of length `count` where `f()` is called
to generate every item.
*/
let repeatWith: (int, unit => 'a) => t<'a>

/**
`forever(item)` is the sequence of `item` repeated forever.
*/
let forever: 'a => t<'a>

/**
`foreverWith(f)` creates an infinite sequence comprised of calling the function
`f` each time an item is generated.
*/
let foreverWith: (unit => 'a) => t<'a>

/**
`iterate(seed, f)` creates an infinite sequence starting with `seed` and
repeatedly calling function `f` on it.
*/
let iterate: ('a, 'a => 'a) => t<'a>

/**
`cycle` is the sequence that consists of an infinite number of repetitions of
the input sequence.
*/
let cycle: t<'a> => t<'a>

/**
`range(start, end)` is the sequence integers from `start` to `end` (inclusive).
If `start` is greater than `end` the sequence of numbers is descending.
*/
let range: (int, int) => t<int>

/**
`rangeMap(start, end, mapper)` is the sequence from that results from calling
`mapper` on each integer from `start` to `end` (inclusive). If `start` is
greater than `end` the numbers descend.
*/
let rangeMap: (int, int, int => 'a) => t<'a>

/**
`fromArray(start, end)` generates a sequence from an array. `start` and `end`
indexes can optionally be provided.
*/
let fromArray: (~start: int=?, ~end: int=?, array<'a>) => t<'a>

/**
`fromList` generates a sequence from a list.
*/
let fromList: list<'a> => t<'a>

/**
`fromOption(opt)` create an empty sequence if the option is `None` and length
`1` (a singleton) otherwise.

## Examples

```rescript
Some(1)->Seq.fromOption // [1]
None->Seq.fromOption // []
```
*/
let fromOption: option<'a> => t<'a>

/**
`characters(s)` is the sequence of characters in the string `s`.
*/
let characters: string => t<string>

/**
`cons(x, xx)` constructs the sequence that begins with the element `x` 
followed by the sequence `xx`.

## Examples

```rescript
cons(1, [2, 3, 4]) // [1, 2, 3, 4]
```
*/
let cons: ('a, t<'a>) => t<'a>

/**
`startsWith(xx, x)` constructs the sequence that begins with the element `x`
followed by the sequence `xx`. This is the same as `cons` but with the arguments
reversed.

## Examples

```rescript
cons(1, [2, 3, 4]) // [1, 2, 3, 4]
```
*/
let startWith: (t<'a>, 'a) => t<'a>

/**
`endWith(xx, x)` is the sequence that begins with `xx` and appends `x` onto the
end.
*/
let endWith: (t<'a>, 'a) => t<'a>

/**
`prepend(xx, yy)` is all items in `yy` followed by all items in `xx`. See
`concat` for the same functionality but the arguments reversed.
*/
let prepend: (t<'a>, t<'a>) => t<'a>

/**
`concat(xx, yy)` is all items in `xx` followed by all items in `yy`. See
`prepend` for the same functionality but the arguments reversed.
*/
let concat: (t<'a>, t<'a>) => t<'a>

/**
`flatten` creates a sequence by concatenating every item in each sub-sequence.
Analogous to the JavaScript `Array.flat` with a depth of 1.
*/
let flatten: t<t<'a>> => t<'a>

/**
`flatMap(source, mapper)` creates a sequence by calling the `mapper` callback on
each item in the source sequence and then concatenating every item produced.
Also known as `bind`. Analogous to `Array.flatMap` in JavaScript.
*/
let flatMap: (t<'a>, 'a => t<'b>) => t<'b>

/**
`map(source, mapper)` is the sequence that results by calling the `mapper` callback on
each item in `source`.
*/
let map: (t<'a>, 'a => 'b) => t<'b>

/**
`map(source, mapper)` is the sequence that results by calling the `mapper`
callback on each item in `source`. The callback receives the zero-based index of
each item.
*/
let mapi: (t<'a>, ('a, int) => 'b) => t<'b>

/**
`indexed` builds a new sequence whose elements are the corresponding elements of
the input sequence paired with the integer index (from 0) of each element.
*/
let indexed: t<'a> => t<('a, int)>

/**
`filter` builds a new sequence containing only the elements of the source for
which the given predicate returns "true". Similar to `Array.filter` in
JavaScript.
*/
let filter: (t<'a>, 'a => bool) => t<'a>

/**
`filteri` builds a new sequence containing only the elements of the source for
which the given predicate returns "true". The callback receives the zero-based
index of each item.
*/
let filteri: (t<'a>, ('a, int) => bool) => t<'a>

/**
`filterMap(source, mapper)` builds a new sequence containing only the elements of `source` for
which the `mapper` callback returns `Some`.
*/
let filterMap: (t<'a>, 'a => option<'b>) => t<'b>

/**
`filterSome` is the sequence of all the `Some` items in the source sequence.
`None` items are ignored.
*/
let filterSome: t<option<'a>> => t<'a>

/**
`filterOk` is the sequence of all the `Ok` items in the source sequence. `Error`
items are ignored.
*/
let filterOk: t<result<'a, 'b>> => t<'a>

/**
`takeAtMost(n)` is the sequence of the first `n` items in the source; remaining
items are discarded.
*/
let takeAtMost: (t<'a>, int) => t<'a>

/**
`takeWhile(xx, predicate)` is the sequence that includes all items from the
beginning of xx up to **but not including** the item where `predicate` is
`false`.
*/
let takeWhile: (t<'a>, 'a => bool) => t<'a>

/**
`takeUntil(xx, predicate)` is the sequence that includes all items from the
beginning of xx up to **and including** the first item where `predicate` is
`false`.
*/
let takeUntil: (t<'a>, 'a => bool) => t<'a>

/**
`drop(xx, count)` is the sequence `xx` that begins after the first `count` items
are discarded.
*/
let drop: (t<'a>, int) => t<'a>

/**
`dropWhile(xx, predicate)` is the sequence that skips items from the
beginning of xx and **starts** at the first item where predicate is `false`.
*/
let dropWhile: (t<'a>, 'a => bool) => t<'a>

/**
`dropUntil(xx, predicate)` is the sequence that skips items from the
beginning of xx and **starts** at the first item where predicate is `true`.
*/
let dropUntil: (t<'a>, 'a => bool) => t<'a>

/**
`scan` is conceptually related to `reduce`. However instead of performing an
eager evaluation and returning the final accumulator, it returns a sequence of
accumulators (partial sums).
*/
let scan: (t<'a>, 'b, ('b, 'a) => 'b) => t<'b>

let scani: (t<'a>, ~zero: 'b, (~sum: 'b, ~val: 'a, ~inx: int) => 'b) => t<'b>

/**
`cache` memoizes the values in a sequence. This is typically useful when
repeatedly evaluating items in the original sequence is computationally
expensive or if iterating the sequence causes side-effects that the user does
not want to be repeated multiple times.
*/
let cache: t<'a> => t<'a>

/**
`tap` inserts a listener into the middle of a sequence so side-effects, like
logging and debugging, can be performed. It returns the original sequence
without modification. This is equivalent to `map` with the identity function.
*/
let tap: (t<'a>, 'a => unit) => t<'a>

let chunkBySize: (t<'a>, int) => t<array<'a>>

/**
`pairwise` is the sequence of each element and its predecessor, with the
exception of the first element that is only returned as the predecessor of the
second. Returns the empty sequence if the input sequence only has a single item.
*/
let pairwise: t<'a> => t<('a, 'a)>

/**
`window(size)` returns a sequence yielding sliding windows of the specified size
containing elements drawn from the input sequence. Each window is returned as a
**shared** array. If the `size` is longer than the input sequence, no windows
are returned.
*/
let window: (t<'a>, int) => t<array<'a>>

let windowBehind: (t<'a>, int) => t<array<'a>>
let windowAhead: (t<'a>, int) => t<array<'a>>

/**
`allPairs(xx,yy)` is the sequence that contains all pairings of items from the
first and second sequences.
*/
let allPairs: (t<'a>, t<'b>) => t<('a, 'b)>

/**
`intersperse(separator)` is the sequence formed by inserting `separator` between
each pair of items in the input sequence. If the input sequence is empty or has
a single value it is not changed in any way.
*/
let intersperse: (t<'a>, 'a) => t<'a>

let intersperseWith: (t<'a>, unit => 'a) => t<'a>

/**
`orElse(xx,yy)` is the sequence `xx` unless it is empty, in which case `yy` is
substituted.
*/
let orElse: (t<'a>, t<'a>) => t<'a>

let map2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>
let map3: (t<'a>, t<'b>, t<'c>, ('a, 'b, 'c) => 'd) => t<'d>
let map4: (t<'a>, t<'b>, t<'c>, t<'d>, ('a, 'b, 'c, 'd) => 'e) => t<'e>
let map5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, ('a, 'b, 'c, 'd, 'e) => 'f) => t<'f>

let zip: (t<'a>, t<'b>) => t<('a, 'b)>
let zip3: (t<'a>, t<'b>, t<'c>) => t<('a, 'b, 'c)>
let zip4: (t<'a>, t<'b>, t<'c>, t<'d>) => t<('a, 'b, 'c, 'd)>
let zip5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>) => t<('a, 'b, 'c, 'd, 'e)>

let sortedMerge: (t<'a>, t<'a>, ('a, 'a) => int) => t<'a>

/**
`interleave(xx,yy)` is the sequence built by alternately taking items from `xx`
and `yy`. When one of those sequences is empty, the remaining items from the
other sequence are returned.
*/
let interleave: (t<'a>, t<'a>) => t<'a>

let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b
let reducei: (t<'a>, ~zero: 'b, (~sum: 'b, ~val: 'a, ~inx: int) => 'b) => 'b
let forEach: (t<'a>, 'a => unit) => unit
let forEachi: (t<'a>, ('a, int) => unit) => unit
let some: (t<'a>, 'a => bool) => bool
let everyOrEmpty: (t<'a>, 'a => bool) => bool
let find: (t<'a>, 'a => bool) => option<'a>
let findMap: (t<'a>, 'a => option<'b>) => option<'b>
let findMapi: (t<'a>, ('a, int) => option<'b>) => option<'b>
let length: t<'a> => int
let isEmpty: t<'a> => bool
let isSortedBy: (t<'a>, ('a, 'a) => int) => bool
let equals: (t<'a>, t<'a>, ('a, 'a) => bool) => bool
let compare: (t<'a>, t<'a>, ('a, 'a) => int) => int

/**
`head` is the first item in the sequence. Returns `None` if the sequence is
empty.
*/
let head: t<'a> => option<'a>

/**
`tail` is the sequence that starts after the head (first item). Equivalent to
`drop` with `1`.
*/
let tail: t<'a> => t<'a>

/**
`headTail` deconstructs the sequence into its head (first item) and the tail
(the rest, possibly empty). If the sequence is empty returns `None`.
*/
let headTail: t<'a> => option<('a, t<'a>)>

/**
`minBy(seq, compare)` eagerly consumes the entire sequence and returns the
minimum item according to the comparator function. Returns `None` if the
sequence is empty.
*/
let minBy: (t<'a>, ('a, 'a) => int) => option<'a>

/**
`maxBy(seq, compare)` eagerly consumes the entire sequence and returns the
maximum item according to the comparator function. Returns `None` if the
sequence is empty.
*/
let maxBy: (t<'a>, ('a, 'a) => int) => option<'a>

/**
`last` eagerly consumes the entire sequence and returns a `Some` for the last
item in it, or `None` if the sequence is empty.
*/
let last: t<'a> => option<'a>

/**
`toArray` eagerly consumes the entire sequence and converts it to an array.
*/
let toArray: t<'a> => array<'a>

/**
`joinString` concatenates every string in the input sequence. Empty sequences
return the empty string. See `intersperse` to insert a separator character
between pairs of strings.
*/
let joinString: t<string> => string

/**
`exactlyOne` checks if the sequence has exactly one item in it, and if so
returns it as `Some`.
*/
let exactlyOne: t<'a> => option<'a>

/**
`toOption` checks if the sequence is empty and if so returns `None`. Otherwise
returns a `Some` non-empty sequence.

**Note:** To check if the sequence is empty, this function eagerly consumes the
first item and then "puts it back".
*/
let toOption: t<'a> => option<t<'a>>

/**
`allOk` returns an `Ok` sequence (possibly empty) if all the input values were
`Ok`. Otherwise returns the first `Error`. Useful for lazy validation because
validation stops when the first `Error` is encountered.
*/
let allOk: t<result<'ok, 'err>> => result<t<'ok>, 'err>

/**
`allSome` returns a `Some` sequence (possibly empty), if all input
values were `Some`. Otherwise returns `None.`
*/
let allSome: t<option<'a>> => option<t<'a>>

/**
`consume` eagerly iterates through every item in the sequence. This is only
useful if side-effects are performed via `tap` or other functions in the
pipeline. Equivalent to `forEach` where the supplied function does nothing.
*/
let consume: t<'a> => unit
