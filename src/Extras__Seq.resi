/**
`t<'a>` represents a lazy sequence whose items are only computed upon demand.
*/
type t<'a>

exception ArgumentOfOfRange(string)

/**
`empty` is a sequence with nothing in it; analogous to an empty array.
*/
let empty: t<'a>

/**
`singleton(value)` is a sequence with a single item in it.
*/
let singleton: 'a => t<'a>

/**
`unfold(seed, f)` creates a sequence that contains the elements generated by a
computation. The function `f` is first passed `seed` and then is repeatedly
called to build the sequence. When `f` returns a tuple of `Some(item, seed)`,
`item` is added to the sequence, and `seed` is fed into the next computation.
When `f` returns `None`, the computation is complete.

## Examples

```rescript
Seq.unfold(1, i => i < 100 ? Some(i, i * 2) : None) // [1, 2, 4, 8, 16, 32, 64]
```
*/
let unfold: ('seed, 'seed => option<('a, 'seed)>) => t<'a>

/**
`init(count, f)` initializes a sequence based on a `count` and a function `f`
that is provided index values from 0 up to `count-1`.

## Examples

```rescript
Seq.init(3, inx => inx * 2) // [0, 2, 4]
```
*/
let init: (int, int => 'a) => t<'a>

/**
`repeat(count, item)` is the sequence of `item` repeated exacly `count` times.
*/
let repeat: (int, 'a) => t<'a>

/**
`repeatWith(count, f)` is the sequence of length `count` where `f()` is called
to generate every item.
*/
let repeatWith: (int, unit => 'a) => t<'a>

/**
`forever(item)` is the sequence of `item` repeated forever.
*/
let forever: 'a => t<'a>

/**
`foreverWith(f)` creates an infinite sequence comprised of calling the function
`f` each time an item is generated.
*/
let foreverWith: (unit => 'a) => t<'a>

/**
`iterate(seed, f)` creates an infinite sequence starting with `seed` and
repeatedly calling function `f` on it.
*/
let iterate: ('a, 'a => 'a) => t<'a>

/**
`cycle` is the sequence that consists of an infinite number of repetitions of
the input sequence.
*/
let cycle: t<'a> => t<'a>

/**
`range(start, end)` is the sequence integers from `start` to `end` (inclusive).
If `start` is greater than `end` the sequence of numbers is descending.
*/
let range: (int, int) => t<int>

/**
`rangeMap(start, end, mapper)` is the sequence from that results from calling
`mapper` on each integer from `start` to `end` (inclusive). If `start` is
greater than `end` the numbers descend.
*/
let rangeMap: (int, int, int => 'a) => t<'a>

/**
`fromArray(start, end)` generates a sequence from an array. `start` and `end`
indexes can optionally be provided.
*/
let fromArray: (~start: int=?, ~end: int=?, array<'a>) => t<'a>

let fromList: list<'a> => t<'a>

/**
`fromOption(opt)` create an empty sequence if the option is `None` and length
`1` (a singleton) otherwise.

## Examples

```rescript
Some(1)->Seq.fromOption // [1]
None->Seq.fromOption // []
```
*/
let fromOption: option<'a> => t<'a>

/**
`characters(s)` is the sequence of characters in the input string.
*/
let characters: string => t<string>

/**
`cons(x, xx)` constructs the sequence that begins with the element `x` 
followed by the sequence `xx`.

## Examples

```rescript
cons(1, [2, 3, 4]) // [1, 2, 3, 4]
```
*/
let cons: ('a, t<'a>) => t<'a>

/**
`startsWith(xx, x)` constructs the sequence that begins with the element `x`
followed by the sequence `xx`. This is the same as `cons` but with the arguments
reversed.

## Examples

```rescript
cons(1, [2, 3, 4]) // [1, 2, 3, 4]
```
*/
let startWith: (t<'a>, 'a) => t<'a>

/**
`endWith(xx, x)` is the sequence that begins with `xx` and appends `x` onto the
end.
*/
let endWith: (t<'a>, 'a) => t<'a>

let prepend: (t<'a>, t<'a>) => t<'a>

let concat: (t<'a>, t<'a>) => t<'a>

let flatten: t<t<'a>> => t<'a>

let flatMap: (t<'a>, 'a => t<'b>) => t<'b>

let map: (t<'a>, 'a => 'b) => t<'b>

let mapi: (t<'a>, ('a, int) => 'b) => t<'b>

let indexed: t<'a> => t<('a, int)>

let filter: (t<'a>, 'a => bool) => t<'a>

let filteri: (t<'a>, ('a, int) => bool) => t<'a>

let filterMap: (t<'a>, 'a => option<'b>) => t<'b>

/**
`filterSome` is the sequence of all the `Some` items in the source sequence.
`None` items are ignored.
*/
let filterSome: t<option<'a>> => t<'a>

/**
`filterOk` is the sequence of all the `Ok` items in the source sequence. `Error`
items are ignored.
*/
let filterOk: t<result<'a, 'b>> => t<'a>

/**
`takeAtMost(n)` is the sequence of the first `n` items in the source; remaining
items are discarded.
*/
let takeAtMost: (t<'a>, int) => t<'a>

/**
`takeWhile(xx, predicate)` is the sequence that includes all items from the
beginning of xx up to **but not including** the item where `predicate` is
`false`.
*/
let takeWhile: (t<'a>, 'a => bool) => t<'a>

/**
`takeUntil(xx, predicate)` is the sequence that includes all items from the
beginning of xx up to **and including** the first item where `predicate` is
`false`.
*/
let takeUntil: (t<'a>, 'a => bool) => t<'a>

/**
`drop(xx, count)` is the sequence `xx` that begins after the first `count` items
are discarded.
*/
let drop: (t<'a>, int) => t<'a>

/**
`dropWhile(xx, predicate)` is the sequence that skips items from the
beginning of xx and **starts** at the first item where predicate is `false`.
*/
let dropWhile: (t<'a>, 'a => bool) => t<'a>

/**
`dropUntil(xx, predicate)` is the sequence that skips items from the
beginning of xx and **starts** at the first item where predicate is `true`.
*/
let dropUntil: (t<'a>, 'a => bool) => t<'a>

/**
`scan` is conceptually related to `reduce`. However instead of performing an
eager evaluation and returning the final accumulator, it returns a sequence of
accumulators (partial sums).
*/
let scan: (t<'a>, 'b, ('b, 'a) => 'b) => t<'b>

let scani: (t<'a>, ~zero: 'b, (~sum: 'b, ~val: 'a, ~inx: int) => 'b) => t<'b>

/**
`cache` memoizes the values in a sequence. This is typically useful when
repeatedly evaluating items in the original sequence is computationally
expensive or if iterating the sequence causes side-effects that the user does
not want to be repeated multiple times.
*/
let cache: t<'a> => t<'a>

/**
`tap` inserts a listener into the middle of a sequence so side-effects, like
logging and debugging, can be performed. It returns the original sequence
without modification. This is equivalent to `map` with the identity function.
*/
let tap: (t<'a>, 'a => unit) => t<'a>

let chunkBySize: (t<'a>, int) => t<array<'a>>

/**
`pairwise` is the sequence of each element and its predecessor, with the
exception of the first element that is only returned as the predecessor of the
second. Returns the empty sequence if the input sequence only has a single item.
*/
let pairwise: t<'a> => t<('a, 'a)>

/**
`window(size)` returns a sequence yielding sliding windows of the specified size
containing elements drawn from the input sequence. Each window is returned as a
**shared** array. If the `size` is longer than the input sequence, no windows
are returned.
*/
let window: (t<'a>, int) => t<array<'a>>

let windowBehind: (t<'a>, int) => t<array<'a>>
let windowAhead: (t<'a>, int) => t<array<'a>>

/**
`allPairs(xx,yy)` is the sequence that contains all pairings of items from the
first and second sequences.
*/
let allPairs: (t<'a>, t<'b>) => t<('a, 'b)>

/**
`intersperse(separator)` is the sequence formed by inserting `separator` between
each pair of items in the input sequence. If the input sequence is empty or has
a single value it is not changed in any way.
*/
let intersperse: (t<'a>, 'a) => t<'a>

let intersperseWith: (t<'a>, unit => 'a) => t<'a>

/**
`orElse(xx,yy)` is the sequence `xx` unless it is empty, in which case `yy` is
substituted.
*/
let orElse: (t<'a>, t<'a>) => t<'a>

let map2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>
let map3: (t<'a>, t<'b>, t<'c>, ('a, 'b, 'c) => 'd) => t<'d>
let map4: (t<'a>, t<'b>, t<'c>, t<'d>, ('a, 'b, 'c, 'd) => 'e) => t<'e>
let map5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, ('a, 'b, 'c, 'd, 'e) => 'f) => t<'f>

let zip: (t<'a>, t<'b>) => t<('a, 'b)>
let zip3: (t<'a>, t<'b>, t<'c>) => t<('a, 'b, 'c)>
let zip4: (t<'a>, t<'b>, t<'c>, t<'d>) => t<('a, 'b, 'c, 'd)>
let zip5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>) => t<('a, 'b, 'c, 'd, 'e)>

let sortedMerge: (t<'a>, t<'a>, ('a, 'a) => int) => t<'a>

/**
`interleave(xx,yy)` is the sequence built by alternately taking items from `xx`
and `yy`. When one of those sequences is empty, the remaining items from the
other sequence are returned.
*/
let interleave: (t<'a>, t<'a>) => t<'a>

let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b
let reducei: (t<'a>, ~zero: 'b, (~sum: 'b, ~val: 'a, ~inx: int) => 'b) => 'b
let forEach: (t<'a>, 'a => unit) => unit
let forEachi: (t<'a>, ('a, int) => unit) => unit
let some: (t<'a>, 'a => bool) => bool
let everyOrEmpty: (t<'a>, 'a => bool) => bool
let find: (t<'a>, 'a => bool) => option<'a>
let findMap: (t<'a>, 'a => option<'b>) => option<'b>
let findMapi: (t<'a>, ('a, int) => option<'b>) => option<'b>
let length: t<'a> => int
let isEmpty: t<'a> => bool
let isSortedBy: (t<'a>, ('a, 'a) => int) => bool
let equals: (t<'a>, t<'a>, ('a, 'a) => bool) => bool
let compare: (t<'a>, t<'a>, ('a, 'a) => int) => int
let head: t<'a> => option<'a>
let tail: t<'a> => t<'a>
let headTail: t<'a> => option<('a, t<'a>)>
let minBy: (t<'a>, ('a, 'a) => int) => option<'a>
let maxBy: (t<'a>, ('a, 'a) => int) => option<'a>
let last: t<'a> => option<'a>
let toArray: t<'a> => array<'a>
let joinString: t<string> => string
let exactlyOne: t<'a> => option<'a>
let toOption: t<'a> => option<t<'a>>

/**
`allOk` returns an `Ok` sequence (possibly empty) if all the input values were
`Ok`. Otherwise returns the first `Error`. Useful for lazy validation because
validation stops when the first `Error` is encountered.
*/
let allOk: t<result<'ok, 'err>> => result<t<'ok>, 'err>

/**
`allSome` returns a `Some` sequence (possibly empty) if all input values were
`Some`. Otherwise returns `None.`
*/
let allSome: t<option<'a>> => option<t<'a>>

/**
`consume` eagerly iterates through every item in the sequence. This is only
useful if side-effects are performed via `tap` or other functions in the
pipeline.
*/
let consume: t<'a> => unit
