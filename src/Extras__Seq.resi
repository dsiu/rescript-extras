/**
`t<'a>` represents a lazy sequence whose items are only computed upon demand.
*/
type t<'a>

exception InvalidArgument(string)

/**
`empty` is a sequence with nothing in it; analogous to an empty array.
*/
let empty: t<'a>

/**
`once(value)` is a sequence of a single item.
*/
let once: 'a => t<'a>

/**
`onceWith(f)` is a sequence composed of a single item, constructed lazily by `f`
*/
let onceWith: (unit => 'a) => t<'a>

/**
`unfold(seed, f)` creates a sequence that contains the elements generated by a
computation. The function `f` is first passed `seed` and then is repeatedly
called to build the sequence. When `f` returns a tuple of `Some(item, seed)`,
`item` is added to the sequence, and `seed` is fed into the next computation.
When `f` returns `None`, the computation is complete.

## Examples

```rescript
Seq.unfold(1, i => i < 100 ? Some(i, i * 2) : None) // [1, 2, 4, 8, 16, 32, 64]
```
*/
let unfold: ('seed, 'seed => option<('a, 'seed)>) => t<'a>

/**
`init(count, f)` initializes a sequence based on a `count` and a function `f`
that is provided index values from 0 up to `count-1`.

## Examples

```rescript
Seq.init(3, inx => inx * 2) // [0, 2, 4]
```
*/
let init: (int, int => 'a) => t<'a>

/**
`replicate(count, item)` is the sequence of `item` repeated exacly `count` times.
*/
let replicate: (int, 'a) => t<'a>

/**
`replicateWith(count, f)` is the sequence of length `count` where `f()` is called
to generate each item.
*/
let replicateWith: (int, unit => 'a) => t<'a>

/**
`forever(item)` is the sequence of `item` repeated forever.
*/
let forever: 'a => t<'a>

/**
`foreverWith(f)` creates an infinite sequence comprised of calling the function
`f` each time an item is generated.
*/
let foreverWith: (unit => 'a) => t<'a>

/**
`iterate(seed, f)` creates an infinite sequence starting with `seed` and
repeatedly calling function `f` on it.
*/
let iterate: ('a, 'a => 'a) => t<'a>

/**
`cycle` is the sequence that consists of an infinite number of repetitions of
the input sequence. If the original sequence is empty, the resulting sequence
will also be empty.

**Note:** The process for generating items is cycled, rather than cycling the
values produced. For example, if the original sequence is based on a function
that generates random numbers, then when the sequence repeats new random numbers
will be produced. If this is not the desired behavior consider using `cache`
before calling `cycle`.
*/
let cycle: t<'a> => t<'a>

/**
`range(start, end)` is the sequence integers from `start` to `end` (inclusive).
If `start` is greater than `end` the sequence of numbers descends.
*/
let range: (int, int) => t<int>

/**
`rangeMap(start, end, mapper)` is the sequence from that results from calling
`mapper` on each integer from `start` to `end` (inclusive). If `start` is
greater than `end` the numbers descend.
*/
let rangeMap: (int, int, int => 'a) => t<'a>

/**
`fromArray(start, end)` generates a sequence from an array. `start` and `end`
indexes can optionally be provided.
*/
let fromArray: (~start: int=?, ~end: int=?, array<'a>) => t<'a>

/**
`fromList` generates a sequence from a list.
*/
let fromList: list<'a> => t<'a>

/**
`fromOption(opt)` create an empty sequence if the option is `None`, and a
sequence with one item otherwise.

## Examples

```rescript
Some(1)->Seq.fromOption // [1]
None->Seq.fromOption // []
```
*/
let fromOption: option<'a> => t<'a>

/**
`cons(x, xx)` constructs the sequence that begins with the element `x` followed
by the sequence `xx`. This is the same as `startsWith` but the arguments are reversed.

## Examples

```rescript
cons(1, [2, 3, 4]) // [1, 2, 3, 4]
```
*/
let cons: ('a, t<'a>) => t<'a>

/**
`prepend(xx, yy)` is all items in `yy` followed by all items in `xx`. See
`concat` for the same functionality but the arguments reversed.
*/
let prepend: (t<'a>, t<'a>) => t<'a>

/**
`concat(xx, yy)` is all items in `xx` followed by all items in `yy`. See
`prepend` for the same functionality but the arguments reversed.
*/
let concat: (t<'a>, t<'a>) => t<'a>

/**
`flatten` creates a sequence by concatenating every item in each sub-sequence.
Analogous to the JavaScript `Array.flat` with a depth of 1.
*/
let flatten: t<t<'a>> => t<'a>

/**
`flatMap(source, mapper)` creates a sequence by calling the `mapper` callback on
each item in the source sequence and then concatenating every item produced.
Also known as `bind`. Analogous to `Array.flatMap` in JavaScript.
*/
let flatMap: (t<'a>, 'a => t<'b>) => t<'b>

/**
`map(source, mapper)` is the sequence that results by calling the `mapper` callback on
each item in `source`.
*/
let map: (t<'a>, 'a => 'b) => t<'b>

/**
`map(source, mapper)` is the sequence that results by calling the `mapper`
callback on each item in `source`. The callback receives the zero-based index of
each item.
*/
let mapi: (t<'a>, ('a, int) => 'b) => t<'b>

/**
`indexed` builds a new sequence whose elements are the corresponding elements of
the input sequence paired with the integer index (from 0) of each element.
*/
let indexed: t<'a> => t<('a, int)>

/**
`filter` builds a new sequence containing only the elements of the source for
which the given predicate returns "true". Similar to `Array.filter` in
JavaScript.
*/
let filter: (t<'a>, 'a => bool) => t<'a>

/**
`filteri` builds a new sequence containing only the elements of the source for
which the given predicate returns "true". The callback receives the zero-based
index of each item.
*/
let filteri: (t<'a>, ('a, int) => bool) => t<'a>

/**
`filterMap(source, mapper)` builds a new sequence containing only the elements of `source` for
which the `mapper` callback returns `Some`.
*/
let filterMap: (t<'a>, 'a => option<'b>) => t<'b>

/**
`filterMap(source, mapper)` builds a new sequence containing only the elements
of `source` for which the `mapper` callback returns `Some`. The callback
receives the zero-based index of each item.
*/
let filterMapi: (t<'a>, ('a, int) => option<'b>) => t<'b>

/**
`filterSome` is the sequence of all the `Some` items in the source sequence.
`None` items are discarded.
*/
let filterSome: t<option<'a>> => t<'a>

/**
`filterOk` is the sequence of all the `Ok` items in the source sequence. `Error`
items are discarded.
*/
let filterOk: t<result<'a, 'b>> => t<'a>

/**
`take(source, count)` is the sequence of the first `count` items of `source`, or
fewer if `source` ends sooner. Remaining items are discarded.
*/
let take: (t<'a>, int) => t<'a>

/**
`takeWhile(source, predicate)` is the sequence that includes all items from the
beginning of `source` up to **but not including** the item where `predicate` is
`false`.
*/
let takeWhile: (t<'a>, 'a => bool) => t<'a>

/**
`takeUntil(source, predicate)` is the sequence that includes all items from the
beginning of `source` up to **and including** the first item where `predicate` is
`false`.
*/
let takeUntil: (t<'a>, 'a => bool) => t<'a>

/**
`drop(source, count)` is the sequence that begins after the first `count` items
are discarded from `source`.
*/
let drop: (t<'a>, int) => t<'a>

/**
`dropWhile(source, predicate)` is the sequence that skips items from the
beginning of `source` and **starts** at the first item where predicate is
`false`. See `dropUntil` to include the last `true` item.
*/
let dropWhile: (t<'a>, 'a => bool) => t<'a>

/**
`dropUntil(source, predicate)` is the sequence that skips items from the
beginning of `source` and **starts** at the first item where predicate is
`true`. See `dropWhile` to exclude the first `true` item.
*/
let dropUntil: (t<'a>, 'a => bool) => t<'a>

/**
`scan(source, zero, accumulator)` is conceptually related to `reduce`. However
instead of performing an eager evaluation and returning the final accumulator,
it returns a sequence of accumulators (partial sums).
*/
let scan: (t<'a>, 'b, ('b, 'a) => 'b) => t<'b>

/**
`cache` memoizes the values in a sequence. This is typically useful when
repeatedly evaluating items in the original sequence is computationally
expensive or if iterating the sequence causes side-effects that the user does
not want to be repeated multiple times.
*/
let cache: t<'a> => t<'a>

/**
`tap` inserts a listener into the middle of a sequence so side-effects, like
logging and debugging, can be performed. It returns the original sequence
without modification. This is equivalent to `map` with the identity function.
*/
let tap: (t<'a>, 'a => unit) => t<'a>

/**
`chunkBySize(source, size)` divides the input sequence into non-overlapping
arrays of adjacent items with at most `size` items in each. The final chunk
might have fewer than `size` items.
*/
let chunkBySize: (t<'a>, int) => t<array<'a>>

/**
`pairwise` is the sequence of each element and its predecessor, with the
exception of the first element that is only returned as the predecessor of the
second. Returns the empty sequence if the source only has a single item.
*/
let pairwise: t<'a> => t<('a, 'a)>

/**
`window(source, size)` returns a sequence of sliding overlapping windows of the
specified size containing elements drawn from `source`. If `size` is longer than
`source`, no windows are returned. Each window is returned as a separate, fresh
array.
*/
let window: (t<'a>, int) => t<array<'a>>

/**
`windowBehind(source, size)` is useful for performing computations on each item
in a sequence and some of its predecessors. This function returns a sequence of
sliding overlapping windows of items drawn from `source` containing at most
`size` items. Each item in `source` is the **last** item in each window and is
preceded by at most `size-1` items.

**Note:** Each window is returned as a shared array. Use `map` to copy each
array to its own instance if necessary.
*/
let windowBehind: (t<'a>, int) => t<array<'a>>

/**
`windowAhead(source, size)` is useful for performing computations on each item
in a sequence and some of the items that follow it. This function returns a sequence of
sliding overlapping windows of items drawn from `source` containing at most
`size` items. Each item in `source` is the **first** item in each window and is
followed by at most `size-1` items.

**Note:** Each window is returned as a shared array. Use `map` to copy each
array to its own instance if necessary.
*/
let windowAhead: (t<'a>, int) => t<array<'a>>

/**
`allPairs(seq1, seq2)` contains all pairings of items from the first and second
sequences.
*/
let allPairs: (t<'a>, t<'b>) => t<('a, 'b)>

/**
`intersperse(separator)` is the sequence formed by inserting `separator` between
each pair of items in the input sequence. If the input sequence is empty or has
a single value it is not modified. See `intersperseWith` if the separator needs
to be computed or might be different each time it is used.
*/
let intersperse: (t<'a>, 'a) => t<'a>

/**
`intersperseWith(separator)` is the sequence formed by inserting a computed
`separator` between each pair of items in the input sequence. If the input
sequence is empty or has a single value it is not modified. See `intersperse` if
the separator is a constant value.
*/
let intersperseWith: (t<'a>, unit => 'a) => t<'a>

/**
`orElse(source, otherwise)` is the sequence `source` unless it is empty, in
which case `otherwise` is substituted.
*/
let orElse: (t<'a>, t<'a>) => t<'a>

/**
`map2(seq1, seq2, mapper)` is the sequence formed by applying the `mapper`
function to corresponding items from the source sequences. If one sequence ends
before the other, the remaining items in the longer sequence are ignored.
*/
let map2: (t<'a>, t<'b>, ('a, 'b) => 'c) => t<'c>

/**
`map3(seq1, seq2, seq3, mapper)` is the sequence formed by applying the `mapper`
function to corresponding items from the source sequences. If one sequence ends
before any of the others, the remaining items in the longer sequences are
ignored.
*/
let map3: (t<'a>, t<'b>, t<'c>, ('a, 'b, 'c) => 'd) => t<'d>

/**
`map4(seq1, seq2, seq3, seq4, mapper)` is the sequence formed by applying the
`mapper` function to corresponding items from the source sequences. If one
sequence ends before any of the others, the remaining items in the longer
sequences are ignored.
*/
let map4: (t<'a>, t<'b>, t<'c>, t<'d>, ('a, 'b, 'c, 'd) => 'e) => t<'e>

/**
`map5(seq1, seq2, seq3, seq4, seq5, mapper)` is the sequence formed by applying
the `mapper` function to corresponding items from the source sequences. If one
sequence ends before any of the others, the remaining items in the longer
sequences are ignored.
*/
let map5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>, ('a, 'b, 'c, 'd, 'e) => 'f) => t<'f>

/**
`zip(seq1, seq2, mapper)` is the sequence formed by combining corresponding
items from the source sequences into a tuple. If one sequence ends before the
other, the remaining items in the longer sequence are ignored.
*/
let zip: (t<'a>, t<'b>) => t<('a, 'b)>

/**
`zip3(seq1, seq2, seq3, mapper)` is the sequence formed by combining corresponding
items from the source sequences into a tuple. If one sequence ends before any of
the others, the remaining items in the longer sequences are ignored.
*/
let zip3: (t<'a>, t<'b>, t<'c>) => t<('a, 'b, 'c)>

/**
`zip4(seq1, seq2, seq3, seq4, mapper)` is the sequence formed by combining
corresponding items from the source sequences into a tuple. If one sequence ends
before any of the others, the remaining items in the longer sequences are
ignored.
*/
let zip4: (t<'a>, t<'b>, t<'c>, t<'d>) => t<('a, 'b, 'c, 'd)>

/**
`zip5(seq1, seq2, seq3, seq4, seq5, mapper)` is the sequence formed by combining
corresponding items from the source sequences into a tuple. If one sequence ends
before any of the others, the remaining items in the longer sequences are
ignored.
*/
let zip5: (t<'a>, t<'b>, t<'c>, t<'d>, t<'e>) => t<('a, 'b, 'c, 'd, 'e)>

/**
`sortedMerge(seq1, seq2, compare)` takes two **sorted** sequences and merges
them into a single **sorted** sequence based on the `compare` function. Once one
of the sequences are exhaused, all the remaining items from the other sequence
are included. 
*/
let sortedMerge: (t<'a>, t<'a>, ('a, 'a) => int) => t<'a>

/**
`interleave(seq1, seq2)` is the sequence built by alternately taking items from `seq1`
and `seq2`. When one of those sequences is empty, the remaining items from the
other sequence are included.
*/
let interleave: (t<'a>, t<'a>) => t<'a>

/**
`reduce(source, zero, accumulator)` invokes `accumulator` successively for every
item in `source`, starting with the provided `zero` value, and returns the final
result.

Reducing (also known as folding) is useful when you have a collection of
something and want to produce a single value from it. This function is analogous
to `Array.reduce` in JavaScript when an initial value is provided.
*/
let reduce: (t<'a>, 'b, ('b, 'a) => 'b) => 'b

/**
`reduceUntil(source, zero, accumulator, predicate)` invokes `accumulator`
successively for items in `source`, starting with the provided `zero` value. The
computation stops after `source` is exhausted, or after `predicate` applied to
`zero` or the current accumulated result is `true`. Returns the first result
where `predicate` is `true` or the final computed value if `predicate` is always
`false`.
*/
let reduceUntil: (t<'a>, 'b, ('b, 'a) => 'b, 'b => bool) => 'b

/**
`reduceWhile(source, zero, accumulator, predicate)` invokes `accumulator`
successively for items in `source`, starting with the provided `zero` value. The
computation stops after `source` is exhausted, or after `predicate` applied to
`zero` or the current accumulated result is `false`. Returns the last result,
if any, where `predicate` is `true`.
*/
let reduceWhile: (t<'a>, 'b, ('b, 'a) => 'b, 'b => bool) => option<'b>

/**
`sumBy(source, accumulator)` invokes `accumulator(sum, item)` successively for
every item in `source`, starting with the first pair of items, and returns the
final result. If `source` has a single item, that value becomes the final result
and `accumulator` is not used. If `source` is empty, returns `None.`

This function is not limited to adding numbers; the `accumulator` can
concatenate strings, append arrays, perform logical operations on booleans, etc.

See `reduce` for a function that takes an initial value and can compute a value
of a different type than items in `source`.
*/
let sumBy: (t<'a>, ('a, 'a) => 'a) => option<'a>

/**
`cumulativeSum(source, accumulator)` calculates the running totals for each item
in `source`. The first item in `source` becomes the first sum in the result.
Subsequent results are computed by `accumulator(sum, item)`. If `source` is
empty, the result is empty.

This function is not limited to adding numbers; the `accumulator` can
concatenate strings, append arrays, perform logical operations on booleans, etc.

See `scan` for a function that takes an initial value and can generate values of
a different type than the source.
*/
let cumulativeSum: (t<'a>, ('a, 'a) => 'a) => t<'a>

/**
`forEach(source, f)` eagerly applies `f` to each item in the sequence. This does
not return any value. It is useful for performing side-effects like logging
values to the console.
*/
let forEach: (t<'a>, 'a => unit) => unit

/**
`forEachi(source, f)` eagerly applies `f` to each item in the sequence. The
callback receives the zero-based index of each item. This does not return any
value. It is useful for performing side-effects like logging values to the
console.
*/
let forEachi: (t<'a>, ('a, int) => unit) => unit

/**
`some(source, predicate)` returns `true` if there exists at least one item where
the supplied predicate is `true`. Returns `false` for an empty sequence or when
no item satisfies the predicate. Analogous to `Array.some` in JavaScript.
*/
let some: (t<'a>, 'a => bool) => bool

/**
`every(source, predicate)` returns `true` if the input sequence is empty or the
supplied predicate is `true` for every item. Analogous to the `for all`
existential quantifier in mathematics and `Array.every` in JavaScript.
*/
let every: (t<'a>, 'a => bool) => bool

/**
`find(source, predicate)` tries to find the first item where `predicate` is
`true`. Returns `None` for an empty sequence or if no such item can be found.
*/
let find: (t<'a>, 'a => bool) => option<'a>

/**
`findMap(source, mapper)` tries to find the first item where `mapper` returns
`Some`. Returns `None` for an empty sequence or if no such item can be found.
*/
let findMap: (t<'a>, 'a => option<'b>) => option<'b>

/**
`findMapi(source, mapper)` tries to find the first item where `mapper` returns
`Some`. The callback receives the zero-based index of each item. Returns `None`
for an empty sequence or if no such item can be found.
*/
let findMapi: (t<'a>, ('a, int) => option<'b>) => option<'b>

/**
`length` returns the number of items in the sequence.
*/
let length: t<'a> => int

/**
`isEmpty` determines if the sequence has any items in it.
*/
let isEmpty: t<'a> => bool

/**
`isSortedBy(source, compare)` determines if the sequence is sorted according to
the provided compare function. Returns `true` for an empty sequence.
*/
let isSortedBy: (t<'a>, ('a, 'a) => int) => bool

/**
`equals(seq1, seq2, areEqual)` determines if two sequences have exactly the same
length and corresponding items in each sequence are equal according to the
`compare` function.
*/
let equals: (t<'a>, t<'a>, ('a, 'a) => bool) => bool

/**
`compare(seq1, seq2, compare)` compares two sequences using the given comparison
function, element by element. Returns the first non-zero result. If the end of a
sequence is reached it return -1 if the first sequence is shorter and 1 if the
second sequence is shorter.
*/
let compare: (t<'a>, t<'a>, ('a, 'a) => int) => int

/**
`head` is the first item in the sequence. Returns `None` if the sequence is
empty.
*/
let head: t<'a> => option<'a>

/**
`tail` is the sequence that starts after the head (first item). Equivalent to
`drop` with `1`.
*/
let tail: t<'a> => t<'a>

/**
`uncons` splits ("un-constructs") the the sequence into its head (first item)
and the tail, which is possibly empty. If the sequence is empty, it returns
`None`.
*/
let uncons: t<'a> => option<('a, t<'a>)>

/**
`minBy(seq, compare)` eagerly consumes the entire sequence and returns the
minimum item according to the comparator function. Returns `None` if the
sequence is empty.
*/
let minBy: (t<'a>, ('a, 'a) => int) => option<'a>

/**
`maxBy(seq, compare)` eagerly consumes the entire sequence and returns the
maximum item according to the comparator function. Returns `None` if the
sequence is empty.
*/
let maxBy: (t<'a>, ('a, 'a) => int) => option<'a>

/**
`last` eagerly consumes the entire sequence and returns a `Some` for the last
item in it, or `None` if the sequence is empty.
*/
let last: t<'a> => option<'a>

/**
`toArray` eagerly consumes the entire sequence and converts it to an array with
items in the same order.
*/
let toArray: t<'a> => array<'a>

/**
`toList` eagerly consumes the entire sequence and converts it to a list with
items in the same order.
*/
let toList: t<'a> => list<'a>

/**
`join(parts, separator)` concatenates every string in `parts`, separated
by `separator`. If `parts` is empty, returns an empty string. If `parts` has
only one string, that string is returned without using the `separator`.
*/
let join: (t<string>, string) => string

/**
`exactlyOne` checks if the sequence has exactly one item in it, and if so
returns it as `Some`.
*/
let exactlyOne: t<'a> => option<'a>

/**
`toOption` checks if the sequence is empty and if so returns `None`. Otherwise
returns a `Some` non-empty sequence.

**Note:** To check if the sequence is empty, this function eagerly consumes the
first item and then "puts it back".
*/
let toOption: t<'a> => option<t<'a>>

/**
`everyOk` returns an `Ok` sequence if all the input values are `Ok` or if the
input sequence is empty. Otherwise returns the first `Error`. This is useful for
lazy validation because validation stops when the first `Error` is encountered.
*/
let everyOk: t<result<'ok, 'err>> => result<t<'ok>, 'err>

/**
`everySome` returns a `Some` sequence if all input values are `Some` or if the
input sequence is empty. Otherwise returns `None.`
*/
let everySome: t<option<'a>> => option<t<'a>>

/**
`consume` eagerly iterates through every item in the sequence and returns
nothing. This is useful if side-effects are performed via `tap` or other
functions in the pipeline. Equivalent to `forEach` where the supplied function
does nothing.
*/
let consume: t<'a> => unit

/**
`reverse(source)` converts the entire sequence to a new array and returns a
sequence corresponding to the items in the reverse order. If `source` is never
iterated then nothing happens.
*/
let reverse: t<'a> => t<'a>

/**
`delay` returns a sequence that is built from the given lazy specifcation of a
sequence.
*/
let delay: (unit => t<'a>) => t<'a>

/**
`sortBy(source, compare)` consumes the entire `source` sequence as soon as that
sequence is iterated. As such it should not be used with large or infinite
sequences. The function uses a stable sort (the original order of equal elements
is preserved) based on the provided `compare` function.
*/
let sortBy: (t<'a>, ('a, 'a) => int) => t<'a>

/**
`combinations(source, size)` generates all combinations of items in `source`,
based on their indexed position (not value), from 1 to `size` items in length.
Each combination is returned as a `(size, sequence)` tuple. A combination is a
unique set; the order in which items are listed is immaterial. 
*/
let combinations: (t<'a>, int) => t<(int, t<'a>)>

/** 
`permutations(source, size)` generates all permutations (ordered arrangements)
of items in `source` based on their indexed position (not value), from 1 to
`size` items in length. Each permutation is returned as a `(size, sequence)`
tuple. 
*/
let permutations: (t<'a>, int) => t<(int, t<'a>)>

/**
`chunkBy(source, init, accumulator)` divides `source` into non-overlapping
groups of adjacent items, computes (via reduce) a "total" of some kind for each
group, and then returns a sequence of group totals. The first group is created
by passing the first item to `init`; this group consists of a single item. The
`accumulator` is then called with subsequent items. If `accumulator` returns
`Some`, the current group total is updated to incorporate the new item. If
`accumulator` returns `None`, that signifies the group is "full" and a new group
is then created using the `init` function.

This function is particularly useful if `source` is sorted. For example, a
sequence of sales could be grouped by month. Each month summary could be a tuple
like `(month, salesTotal)` or `(month, salesArray)`. The grouping criteria and
summarization approach is completely customizable based on the `init` and
`accumulator` functions you provide.
*/
let chunkBy: (t<'a>, 'a => 'b, ('b, 'a) => option<'b>) => t<'b>

/**
`chunkByKey(source, key, equals, init, accumulator)` divides `source` into
non-overlapping groups of adjacent items based on `key`, create a reduction (a
summary or total) for items each group, and returns a sequence of `(key, total)`
tuples.

The first item in `source` is used to create the first group using `init`. Items
from `source` are "added" to the group using `accumulator`, until the key
changes (based on the provided `equals` function), which triggers the creation
of the next group. 
*/
let chunkByKey: (
  t<'a>,
  ~key: 'a => 'key,
  ~equals: ('key, 'key) => bool,
  ~init: 'a => 'b,
  ~accumulator: ('b, 'a) => 'b,
) => t<('key, 'b)>
