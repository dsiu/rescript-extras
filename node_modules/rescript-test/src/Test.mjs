// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function exit(code) {
  if (typeof process !== "undefined") {
    process.exit(code);
  } else {
    console.log("# Exit code: " + code.toString() + "");
  }
}

function red(text) {
  if (typeof process !== "undefined") {
    return "\u001b[31m" + text + "\u001b[0m";
  } else {
    return text;
  }
}

function green(text) {
  if (typeof process !== "undefined") {
    return "\u001b[32m" + text + "\u001b[0m";
  } else {
    return text;
  }
}

function pink(text) {
  if (typeof process !== "undefined") {
    return "\u001b[34m" + text + "\u001b[0m";
  } else {
    return text;
  }
}

function yellow(text) {
  if (typeof process !== "undefined") {
    return "\u001b[33m" + text + "\u001b[0m";
  } else {
    return text;
  }
}

function grey(text) {
  if (typeof process !== "undefined") {
    return "\u001b[2m" + text + "\u001b[0m";
  } else {
    return text;
  }
}

var passText = green("PASS");

var failText = red("FAIL");

var todoText = yellow("TODO");

var running = {
  contents: false
};

var testCounter = {
  contents: 0
};

var testPassedCounter = {
  contents: 0
};

var testFailedCounter = {
  contents: 0
};

var testTimeoutCounter = {
  contents: 0
};

function testText(name, index) {
  var index$1 = index.toString();
  var total = testCounter.contents.toString();
  console.log("" + index$1 + "/" + total + ": " + name + "");
}

var passCounter = {
  contents: 0
};

var failCounter = {
  contents: 0
};

function total(param) {
  return (passCounter.contents + failCounter.contents | 0).toString();
}

var queue = {
  contents: /* [] */0
};

function registerTest(test) {
  queue.contents = {
    hd: test,
    tl: queue.contents
  };
}

function formatMessage(message) {
  if (message !== undefined) {
    return " - " + message + "";
  } else {
    return grey(" - No message");
  }
}

function assertion(message, operator, compare, a, b) {
  if (Curry._2(compare, a, b)) {
    passCounter.contents = passCounter.contents + 1 | 0;
    console.log("  " + passText + "" + formatMessage(message) + "");
  } else {
    failCounter.contents = failCounter.contents + 1 | 0;
    console.log("  " + failText + "" + formatMessage(message) + "");
    console.log("    ---");
    if (operator !== undefined) {
      console.log("    " + pink("operator") + ": " + operator + "");
    }
    console.log("    " + pink("left") + ": ", a);
    console.log("    " + pink("right") + ":", b);
    console.log("    ...");
  }
}

function doesNotThrow(message, func) {
  try {
    Curry._1(func, undefined);
    passCounter.contents = passCounter.contents + 1 | 0;
    console.log("  " + passText + "" + formatMessage(message) + "");
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    failCounter.contents = failCounter.contents + 1 | 0;
    console.log("  " + failText + "" + formatMessage(message) + "");
    console.log("    ---");
    console.log("    " + pink("operator") + ": doesNotThrow");
    console.log("    " + pink("error") + ":", exn);
    console.log("    ...");
    return ;
  }
}

function throws(message, test, func) {
  try {
    Curry._1(func, undefined);
    failCounter.contents = failCounter.contents + 1 | 0;
    console.log("  " + failText + "" + formatMessage(message) + "");
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (test !== undefined && Curry._1(test, exn) === false) {
      failCounter.contents = failCounter.contents + 1 | 0;
      console.log("  " + failText + "" + formatMessage(message) + "");
      return ;
    }
    passCounter.contents = passCounter.contents + 1 | 0;
    console.log("  " + passText + "" + formatMessage(message) + "");
    return ;
  }
}

function todo(message) {
  console.log("  " + todoText + "" + formatMessage(message) + "");
}

function pass(message, param) {
  passCounter.contents = passCounter.contents + 1 | 0;
  console.log("  " + passText + "" + formatMessage(message) + "");
}

function fail(message, param) {
  failCounter.contents = failCounter.contents + 1 | 0;
  console.log("  " + failText + "" + formatMessage(message) + "");
  console.log("    ---");
  console.log("    " + pink("operator") + ": fail");
  console.log("    ...");
}

function testAsync(name, timeoutOpt, func) {
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 5000;
  if (running.contents) {
    console.error(red("# Cannot add testAsync(\"" + name + "\", ...), tests must be defined at the top level"));
    return ;
  }
  testCounter.contents = testCounter.contents + 1 | 0;
  var index = testCounter.contents;
  registerTest(function (resolve) {
        var failedAtStart = failCounter.contents;
        var passedAtStart = passCounter.contents;
        testText(name, index);
        try {
          var timeoutId = setTimeout((function (param) {
                  var message = "Timed out after " + timeout.toString() + "ms";
                  testTimeoutCounter.contents = testTimeoutCounter.contents + 1 | 0;
                  console.log("  " + failText + "" + formatMessage(message) + "");
                  Curry._1(resolve, undefined);
                }), timeout);
          return Curry._1(func, (function (planned, param) {
                        if (planned !== undefined) {
                          assertion("Correct assertion count", "planned", (function (a, b) {
                                  return a === b;
                                }), planned, (passCounter.contents + failCounter.contents | 0) - (passedAtStart + failedAtStart | 0) | 0);
                        }
                        clearTimeout(timeoutId);
                        if (failCounter.contents > failedAtStart) {
                          testFailedCounter.contents = testFailedCounter.contents + 1 | 0;
                        } else {
                          testPassedCounter.contents = testPassedCounter.contents + 1 | 0;
                        }
                        Curry._1(resolve, undefined);
                      }));
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          console.error(exn);
          return exit(1);
        }
      });
}

function testAsyncWith(setup, teardown, name, timeout, func) {
  testAsync(name, timeout, (function (callback) {
          var value = Curry._1(setup, undefined);
          Curry._2(func, value, (function (planned, param) {
                  try {
                    if (teardown !== undefined) {
                      Curry._1(teardown, value);
                    }
                    
                  }
                  catch (raw_exn){
                    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                    console.error(exn);
                    exit(1);
                  }
                  Curry._2(callback, planned, undefined);
                }));
        }));
}

function test(name, func) {
  if (running.contents) {
    console.error(red("# Cannot add test(\"" + name + "\", ...), tests must be defined at the top level"));
    return ;
  }
  testCounter.contents = testCounter.contents + 1 | 0;
  var index = testCounter.contents;
  registerTest(function (resolve) {
        var failedAtStart = failCounter.contents;
        testText(name, index);
        try {
          Curry._1(func, undefined);
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          console.error(exn);
          exit(1);
        }
        if (failCounter.contents > failedAtStart) {
          testFailedCounter.contents = testFailedCounter.contents + 1 | 0;
        } else {
          testPassedCounter.contents = testPassedCounter.contents + 1 | 0;
        }
        Curry._1(resolve, undefined);
      });
}

function testWith(setup, teardown, name, func) {
  test(name, (function (param) {
          var value = Curry._1(setup, undefined);
          Curry._1(func, value);
          if (teardown !== undefined) {
            return Curry._1(teardown, value);
          }
          
        }));
}

var autoBoot = {
  contents: true
};

function runTests(param) {
  running.contents = true;
  var onEnd = function (param) {
    console.log("");
    console.log(grey("# Ran " + String(testCounter.contents) + " tests (" + total(undefined) + " assertions)"));
    console.log(grey("# " + String(testPassedCounter.contents) + " passed"));
    console.log(grey("# " + String(testFailedCounter.contents + testTimeoutCounter.contents | 0) + " failed" + (
              testTimeoutCounter.contents > 0 ? " (" + String(testTimeoutCounter.contents) + " timed out)" : ""
            ) + ""));
    if ((testFailedCounter.contents + testTimeoutCounter.contents | 0) > 0) {
      return exit(1);
    } else {
      return exit(0);
    }
  };
  var tests = Belt_List.reverse(queue.contents);
  var runNextTest = function (tests) {
    if (tests) {
      var rest = tests.tl;
      return Curry._1(tests.hd, (function (param) {
                    runNextTest(rest);
                  }));
    }
    Curry._1(onEnd, undefined);
  };
  runNextTest(tests);
}

setTimeout((function (param) {
        if (autoBoot.contents) {
          return runTests(undefined);
        }
        
      }), 0);

export {
  assertion ,
  pass ,
  fail ,
  todo ,
  doesNotThrow ,
  throws ,
  testAsync ,
  test ,
  testAsyncWith ,
  testWith ,
  autoBoot ,
  runTests ,
}
/* passText Not a pure module */
